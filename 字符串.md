# 最小表示法

```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef pair<int, int> PII;
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
const int N = 6e5 + 100;
int a[N], n;
int getmin()
{
    int i = 1, j = 2, k;
    while (i <= n && j <= n)
    {
        for (k = 0; k < n && a[i + k] == a[j + k]; k++);
        if (a[i + k] > a[j + k])
            i = i + k + 1;
        else
            j = j + k + 1;
        if (i == j)
            j++;
    }
    return min(i, j);
}
int main()
{
    IOS;
    cin >> n;
  	//注意需要复制一倍!
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i + n] = a[i];
    }
    int pos = getmin();
    for (int i = pos; i < pos + n; i++)
        cout << a[i] << ' ';

    return 0;
}
```



# KMP(char)

时间复杂度：$O(n+m)$ 两个串的长度和

最小循环串是多长`len=（字符串长度-next【字符串长】）`

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 100;
int ne[N], n, m;
char p[N], s[N];
void pre()
{
    for (ll i = 2, j = 0; i <= n; i++)
    {
        while (j && p[i] != p[j + 1])
            j = ne[j];
        if (p[i] == p[j + 1])
            j++;
        ne[i] = j;
    }
}
ll kmp()
{
    ll ans = 0;
    for (ll i = 1, j = 0; i <= m; i++)
    {
        while (j && s[i] != p[j + 1])
            j = ne[j];
        if (s[i] == p[j + 1])
        {
            j++;
            if (j == n)
                cout << i - n << endl, ans++, j = ne[j]; //输出匹配位置
        }
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin >> (s + 1) >> (p + 1);
    m = strlen(s + 1); //长串
    n = strlen(p + 1); //短串
    pre();
    cout << kmp();

    return 0;
}
```

# AC自动机

```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef pair<int, int> PII;
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
const int N = 1e6 + 100;
int ch[N][26], fail[N], cnt[N], idx;
char s[N];
void insert(string str)
{
    int p = 0;
    for (int i = 0; str[i]; i++)
    {
        int u = str[i] - 'a';
        if (!ch[p][u])
            ch[p][u] = ++idx;
        p = ch[p][u];
    }
    cnt[p]++;
}
void build()
{
    queue<int> q;
    for (int i = 0; i < 26; i++)
    {
        if (ch[0][i])
            q.push(ch[0][i]);
    }
    while (q.size())
    {
        int t = q.front();
        q.pop();
        for (int i = 0; i < 26; i++)
        {
            int &p = ch[t][i];
            if (!p)
                p = ch[fail[t]][i];
            else
            {
                fail[p] = ch[fail[t]][i];
                q.push(p);
            }
        }
    }
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("0.in", "r", stdin);
#endif
    IOS;
    int T;
    cin >> T;
    while (T--)
    {
        int n;
        cin >> n;
        for (int i = 0; i <= idx; i++)
        {
            memset(ch[i], 0, sizeof ch[i]);
            fail[i] = 0;
            cnt[i] = 0;
        }
        idx = 0;
        while (n--)
        {
            string str;
            cin >> str;
            insert(str);
        }
        build();
        cin >> (s + 1);
        int res = 0;
        for (int t = 1, i = 0; s[t]; t++)
        {
            i = ch[i][s[t] - 'a'];
            for (int j = i; j; j = fail[j])
            {
                res += cnt[j];
                cnt[j] = 0;
            }
        }
        cout << res << endl;
    }

    return 0;
}
```



# z函数

```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef pair<int, int> PII;
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
const int N = 2e7 + 100;
char a[N], b[N];
int z[N], p[N], n, m;
void get_z()
{
    z[1] = n;
    for (int i = 2, l, r = 0; i <= n; i++)
    {
        if (i <= r)
            z[i] = min(z[i - l + 1], r - i + 1);
        while (a[1 + z[i]] == a[i + z[i]])
            z[i]++;
        if (r < i + z[i] - 1)
            r = i + z[i] - 1, l = i;
    }
}
void get_p()
{
    for (int i = 1, l, r = 0; i <= m; i++)
    {
        if (i <= r)
            p[i] = min(z[i - l + 1], r - i + 1);
        while (1 + p[i] <= n && i + p[i] <= m && a[1 + p[i]] == b[i + p[i]])
            p[i]++;
        if (p[i] + i - 1 > r)
            r = p[i] + i - 1, l = i;
    }
}

int main()
{
    IOS;
    cin >> (b + 1) >> (a + 1);
    n = strlen(a + 1), m = strlen(b + 1);
    get_z();
    get_p();
    ll res1 = z[1] + 1, res2 = p[1] + 1;
    for (int i = 2; i <= n; i++)
        res1 ^= 1ll * i * (z[i] + 1);
    for (int i = 2; i <= m; i++)
        res2 ^= 1ll * i * (p[i] + 1);
    cout << res1 << endl<< res2 << endl;
    return 0;
}
```



# Manacher

```c++
// Luogu P3805 【模板】manacher 算法
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 3e7;
char a[N], s[N];
int d[N]; //回文半径函数

void get_d(char *s, int n)
{
    d[1] = 1;
    for (int i = 2, l, r = 1; i <= n; i++)
    {
        if (i <= r)
            d[i] = min(d[r - i + l], r - i + 1);
        while (s[i - d[i]] == s[i + d[i]])
            d[i]++;
        if (i + d[i] - 1 > r)
            l = i - d[i] + 1, r = i + d[i] - 1;
    }
}
int main()
{
    //改造串
    scanf("%s", a + 1);
    int n = strlen(a + 1), k = 0;
    s[0] = '$', s[++k] = '#';
    for (int i = 1; i <= n; i++)
        s[++k] = a[i], s[++k] = '#';
    n = k;
    get_d(s, n); //计算d函数
    int ans = 0;
    for (int i = 1; i <= n; i++)
        ans = max(ans, d[i]);
    printf("%d\n", ans - 1);
    return 0;
}
```



# 后缀自动机(SAM)

```c++
// Luogu P3804 【模板】后缀自动机 (SAM)
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

typedef long long LL;
const int N = 2e6 + 10;
char str[N];
vector<int> e[N]; //邻接表
LL cnt[N], ans;
int tot = 1, np = 1;
// fa链接边终点,ch转移边终点,len最长串长度
int fa[N], ch[N][26], len[N];

void extend(int c)
{
    // p回跳指针, np新点, q链接点, nq新链接点
    int p = np;
    np = ++tot; // p指向旧点, np是新点
    len[np] = len[p] + 1;
    cnt[np] = 1; //子串出现次数
    // p沿链接边回跳，从旧点向新点建转移边
    for (; p && !ch[p][c]; p = fa[p])
        ch[p][c] = np;

    // 1.如果c是新字符，从新点向根节点建链接边
    if (p == 0)
        fa[np] = 1;
    else
    {                     //如果c是旧字符
        int q = ch[p][c]; // q是链接点
        // 2.若链接点合法，从新点向q建链接边
        if (len[q] == len[p] + 1)
            fa[np] = q;
        // 3.若链接点不合法，则裂开q点，重建两类边
        else
        {
            int nq = ++tot; // nq是新链接点
            len[nq] = len[p] + 1;
            //重建nq,q,np的链接边
            fa[nq] = fa[q];
            fa[q] = nq;
            fa[np] = nq;
            //指向q的转移边改为指向nq
            for (; p && ch[p][c] == q; p = fa[p])
                ch[p][c] = nq;
            //从q发出的转移边复制给nq
            memcpy(ch[nq], ch[q], sizeof(ch[q]));
        }
    }
}
void dfs(int u)
{
    for (auto v : e[u])
    {
        dfs(v);
        cnt[u] += cnt[v];
    }
    if (cnt[u] > 1)
        ans = max(ans, cnt[u] * len[u]);
}
int main()
{
    scanf("%s", str);
    for (int i = 0; str[i]; i++)
        extend(str[i] - 'a');
    for (int i = 2; i <= tot; i++)
        e[fa[i]].push_back(i);
    dfs(1);
    printf("%lld\n", ans);
    return 0;
}
```



# 回文自动机(PAM)

```c++
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
typedef long long ll;
typedef pair<int, int> PII;
#define IOS ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)
const int N = 3e5 + 100;
char s[N];
namespace pam
{
    int sz, tot, last;
    int fail[N], ch[N][26], s[N], len[N], cnt[N];

    int node(int l)
    {
        sz++;
        cnt[sz] = fail[sz] = 0;
        memset(ch[sz], 0, sizeof ch[sz]);
        len[sz] = l;
        return sz;
    }

    void clear()
    {
        sz = -1;
        last = 0;
        s[tot = 0] = '$';
        node(0);
        node(-1);
        fail[0] = 1;
    }
    int getfail(int x)
    {
        while (s[tot - len[x] - 1] != s[tot])
            x = fail[x];
        return x;
    }
    void insert(char c)
    {
        s[++tot] = c;
        int now = getfail(last);
        if (!ch[now][c - 'a'])
        {
            int x = node(len[now] + 2);
            fail[x] = ch[getfail(fail[now])][c - 'a'];
            ch[now][c - 'a'] = x;
        }
        last = ch[now][c - 'a'];
        cnt[last]++;
    }
    ll sol()
    {
        for (int i = sz; i >= 0; i--)
        {
            cnt[fail[i]] += cnt[i];
        }
        ll res = 0;
        for (int i = 1; i <= sz; i++)
        {
            res = max(res, (ll)cnt[i] * len[i]);
        }
        return res;
    }
}

int main()
{
    IOS;
    pam::clear();
    cin >> (s + 1);
    for (int i = 1; s[i]; i++)
    {
        pam::insert(s[i]);
    }
    ll res = pam::sol();
    cout << res << endl;
    return 0;
}
```



# 字符串哈希

```c++
typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

# 二维字符串哈希

Hint:两次需要使用不同的进制数

1.对$n*m$的矩阵进行二维哈希

```c++
base1=1331,base2=131;
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        char x;
        cin>>x;
        h[i][j]=h[i][j-1]*base1+x;
    }
for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
        h[i][j]=h[i][j]+h[i-1][j]*base2;

```

2.对区域$[x1,y1,x2,y2]$求哈希

```c++
ull get(int x1,int y1,int x2,int y2)
{
    return h[x2][y2]-h[x2][y1-1]*p1[y2-y1+1]-h[x1-1][y2]*p2[x2-x1+1]
      +h[x1-1][y1-1]*p1[y2-y1+1]*p2[x2-x1+1];
}
```



# 后缀数组

```c++
// Luogu P3809 【模板】后缀排序
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

const int N = 2000010;
char s[N];
int n, m; // n为后缀个数, m为桶的个数
int x[N], y[N], c[N], sa[N], rk[N], height[N];
//桶数组x[i],辅助数组y[i],计数数组c[i]
void get_sa()
{
    int i, j, k;
    //按第一个字母排序
    for (i = 1; i <= n; i++)
        c[x[i] = s[i]]++;
    for (i = 1; i <= m; i++)
        c[i] += c[i - 1];
    for (i = n; i; i--)
        sa[c[x[i]]--] = i;
    for (k = 1; k <= n; k <<= 1)
    { // logn轮
        //按第二关键字排序
        memset(c, 0, sizeof(c));
        for (i = 1; i <= n; i++)
            y[i] = sa[i];
        for (i = 1; i <= n; i++)
            c[x[y[i] + k]]++;
        for (i = 1; i <= m; i++)
            c[i] += c[i - 1];
        for (i = n; i; i--)
            sa[c[x[y[i] + k]]--] = y[i];
        //按第一关键字排序
        memset(c, 0, sizeof(c));
        for (i = 1; i <= n; i++)
            y[i] = sa[i];
        for (i = 1; i <= n; i++)
            c[x[y[i]]]++;
        for (i = 1; i <= m; i++)
            c[i] += c[i - 1];
        for (i = n; i; i--)
            sa[c[x[y[i]]]--] = y[i];
        //把后缀放入桶数组
        for (i = 1; i <= n; i++)
            y[i] = x[i];
        for (m = 0, i = 1; i <= n; i++)
            if (y[sa[i]] == y[sa[i - 1]] &&
                y[sa[i] + k] == y[sa[i - 1] + k])
                x[sa[i]] = m;
            else
                x[sa[i]] = ++m;
        if (m == n)
            break; //已排好
    }
}
void get_height()
{
    int i, j, k;
    for (i = 1; i <= n; i++)
        rk[sa[i]] = i;
    for (i = 1, k = 0; i <= n; i++)
    { //枚举后缀i
        if (rk[i] == 1)
            continue; //第一名height为0
        if (k)
            k--;               //上一个后缀的height值减1
        int j = sa[rk[i] - 1]; //找出后缀i的前邻后缀j
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k])
            k++;
        height[rk[i]] = k;
    }
}
int main()
{
    scanf("%s", s + 1);
    n = strlen(s + 1);
    m = 122;
    get_sa();
    get_height();
    for (int i = 1; i <= n; i++)
        printf("%d ", sa[i]);
    // puts("");
    // for(int i=1;i<=n;i++)printf("%d ",height[i]);
    return 0;
}
```



# 标准库

- `printf("%s", s)`：用 `%s` 来输出一个字符串（字符数组）。
- `scanf("%s", &s)`：用 `%s` 来读入一个字符串（字符数组）。
- `sscanf(const char *__source, const char *__format, ...)`：从字符串 `__source` 里读取变量，比如 `sscanf(str,"%d",&a)`。
- `sprintf(char *__stream, const char *__format, ...)`：将 `__format` 字符串里的内容输出到 `__stream` 中，比如 `sprintf(str,"%d",i)`。
- `strlen(const char *str)`：返回从 `str[0]` 开始直到 `'\0'` 的字符数。注意，未开启 O2 优化时，该操作写在循环条件中复杂度是 的。
- `strcmp(const char *str1, const char *str2)`：按照字典序比较 `str1 str2` 若 `str1` 字典序小返回负值，两者一样返回 `0`，`str1` 字典序更大则返回正值。请注意，不要简单的认为返回值只有 `0`、`1`、`-1` 三种，在不同平台下的返回值都遵循正负，但并非都是 `0`、`1`、`-1`。
- `strcpy(char *str, const char *src)`: 把 `src` 中的字符复制到 `str` 中，`str` `src` 均为字符数组头指针，返回值为 `str` 包含空终止符号 `'\0'`。
- `strncpy(char *str, const char *src, int cnt)`：复制至多 `cnt` 个字符到 `str` 中，若 `src` 终止而数量未达 `cnt` 则写入空字符到 `str` 直至写入总共 `cnt` 个字符。
- `strcat(char *str1, const char *str2)`: 将 `str2` 接到 `str1` 的结尾，用 `*str2` 替换 `str1` 末尾的 `'\0'` 返回 `str1`。
- `strstr(char *str1, const char *str2)`：若 `str2` 是 `str1` 的子串，则返回 `str2` 在 `str1` 的首次出现的地址；如果 `str2` 不是 `str1` 的子串，则返回 `NULL`。
- `strchr(const char *str, int c)`：找到在字符串 `str` 中第一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL`。
- `strrchr(const char *str, char c)`：找到在字符串 `str` 中最后一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL`。
